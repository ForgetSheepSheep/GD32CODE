# GD32 嵌入式开发例程详细分析

## 目录

1. [项目整体架构](#项目整体架构)
2. [例程详细分析](#例程详细分析)
   - [例程01: DWT延时](#例程01-dwt延时)
   - [例程02: LED架构](#例程02-led架构)
   - [例程03: KEY_EXTI](#例程03-key_exti)
   - [例程04: KEY_SYSTICK_STATE](#例程04-key_systick_state)
   - [例程05: UART基础](#例程05-uart基础)
   - [例程06: UART控制](#例程06-uart控制)
   - [例程07: UART应用层](#例程07-uart应用层)
   - [例程08: UART队列](#例程08-uart队列)
   - [例程09: UART DMA](#例程09-uart-dma)
   - [例程10: 任务运行管理](#例程10-任务运行管理)
   - [例程11: 定时器计数](#例程11-定时器计数)
   - [例程12: 输出比较(PWM)](#例程12-输出比较pwm)
   - [例程13: 输入捕获](#例程13-输入捕获)
   - [例程14: IR_NEC红外解码](#例程14-ir_nec红外解码)
   - [例程15: 输入捕获进阶](#例程15-输入捕获进阶)
   - [例程16: 时间戳和日历转换](#例程16-时间戳和日历转换)
3. [STM32移植要点](#stm32移植要点)

---

## 项目整体架构

### 目录结构
```
GD32项目/
├── App/                    # 应用层代码（业务逻辑）
├── Driver/                 # 驱动层代码（硬件抽象）
├── Sys/                    # 系统模块（延时、系统时钟）
├── Library/                # GD32标准库
├── User/                   # 用户代码（main函数）
├── Project/                # 项目配置和编译文件
└── Startup/                # 启动文件
```

### 分层设计原则

| 层级 | 职责 | 示例 |
|------|------|------|
| **应用层 (App)** | 业务逻辑、协议解析、任务调度 | `app_uart.c`, `app_key.c` |
| **驱动层 (Driver)** | 硬件抽象、外设初始化、底层操作 | `drv_led.c`, `drv_uart.c` |
| **系统层 (Sys)** | 系统基础设施（延时、时间基准） | `delay.c`, `sys_tick.c` |

---

## 例程详细分析

### 例程01: DWT延时

#### 功能说明
使用 Cortex-M 内核的 DWT（Data Watchpoint and Trace）单元实现高精度延时。

#### 核心代码分析

```c
// delay_init() - 初始化DWT计数器
void delay_init(void)
{
    CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;  // 使能TRC
    DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;           // 使能CYCCNT计数
    DWT->CYCCNT = 0;                               // 清零计数器
}

// delay_us() - 微秒级延时
void delay_us(uint32_t us)
{
    // 将us转换为CPU时钟周期数
    us *= (rcu_clock_freq_get(CK_AHB) / 1000000);
    uint32_t tickStart = DWT->CYCCNT;
    while ((DWT->CYCCNT - tickStart) < us);  // 等待指定周期数
}
```

#### 代码思路

1. **DWT计数器原理**：
   - DWT->CYCCNT 是32位循环计数器，每个CPU时钟周期自动+1
   - 通过读取计数器差值实现精确计时

2. **延时计算**：
   - CPU频率120MHz → 1us = 120个周期
   - 公式：`周期数 = 延时时间(μs) × (CPU频率 / 1000000)`

3. **注意事项**：
   - 使用无符号减法避免32位溢出问题
   - 这是忙等待方式，占用CPU资源

#### STM32移植要点

| GD32 | STM32 | 说明 |
|------|-------|------|
| `rcu_clock_freq_get(CK_AHB)` | `HAL_RCC_GetHCLKFreq()` | 获取系统时钟频率 |
| `DWT->CYCCNT` | `DWT->CYCCNT` | 相同，Cortex-M标准 |
| 初始化代码 | 相同 | 完全兼容 |

---

### 例程02: LED架构

#### 功能说明
实现模块化的LED驱动，使用结构体数组管理多个LED。

#### 核心代码分析

```c
// LED硬件信息结构体
typedef struct {
    rcu_periph_enum rcu;      // 时钟
    uint32_t gpio;           // GPIO端口
    uint32_t gpio_pin;       // GPIO引脚
} Led_GPIO_t;

// LED硬件配置表
static const Led_GPIO_t g_gpio_list[] = {
    {RCU_GPIOA, GPIOA, GPIO_PIN_8},   // LED1: PA8
    {RCU_GPIOE, GPIOE, GPIO_PIN_6},   // LED2: PE6
    {RCU_GPIOF, GPIOF, GPIO_PIN_6},   // LED3: PF6
};

// LED初始化
void drv_led_init(void)
{
    for (uint8_t i = 0; i < LED_NUM_MAX; i++) {
        rcu_periph_clock_enable(g_gpio_list[i].rcu);
        gpio_init(g_gpio_list[i].gpio, GPIO_MODE_OUT_PP,
                  GPIO_OSPEED_10MHZ, g_gpio_list[i].gpio_pin);
        gpio_bit_reset(g_gpio_list[i].gpio, g_gpio_list[i].gpio_pin);
    }
}

// 点亮LED
void drv_led_on(uint8_t led_id)
{
    if(led_id >= LED_NUM_MAX) return;
    gpio_bit_set(g_gpio_list[led_id].gpio, g_gpio_list[led_id].gpio_pin);
}
```

#### 代码思路

1. **硬件抽象设计**：
   - 使用结构体封装GPIO配置信息
   - 通过数组实现多LED统一管理

2. **初始化流程**：
   - 遍历配置表，使能每个GPIO的时钟
   - 配置为推挽输出模式，10MHz速度
   - 初始状态设为低电平（LED灭）

3. **操作函数**：
   - 参数检查：防止数组越界
   - `gpio_bit_set()` / `gpio_bit_reset()` 操作对应位

#### STM32移植要点

| GD32 | STM32 | 说明 |
|------|-------|------|
| `rcu_periph_clock_enable()` | `__HAL_RCC_GPIOx_CLK_ENABLE()` | 使能GPIO时钟 |
| `gpio_init()` | `HAL_GPIO_Init()` | GPIO初始化 |
| `gpio_bit_set()` | `HAL_GPIO_WritePin(GPIOx, PIN, GPIO_PIN_SET)` | 置高电平 |
| `gpio_bit_reset()` | `HAL_GPIO_WritePin(GPIOx, PIN, GPIO_PIN_RESET)` | 置低电平 |
| `GPIO_MODE_OUT_PP` | `GPIO_MODE_OUTPUT_PP` | 推挽输出模式 |
| `GPIO_OSPEED_10MHZ` | `GPIO_SPEED_FREQ_LOW/MEDIUM/HIGH/VERY_HIGH` | GPIO速度 |

**移植示例代码**：
```c
// STM32 HAL版本
typedef struct {
    GPIO_TypeDef *port;    // GPIO端口指针
    uint16_t pin;         // GPIO引脚
} Led_GPIO_t;

static const Led_GPIO_t led_list[] = {
    {GPIOA, GPIO_PIN_8},
    {GPIOB, GPIO_PIN_0},
    {GPIOC, GPIO_PIN_13},
};

void drv_led_init(void)
{
    GPIO_InitTypeDef GPIO_InitStruct = {0};

    for (int i = 0; i < LED_NUM_MAX; i++) {
        // GPIO时钟使能需根据port判断
        if (led_list[i].port == GPIOA)
            __HAL_RCC_GPIOA_CLK_ENABLE();

        GPIO_InitStruct.Pin = led_list[i].pin;
        GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
        GPIO_InitStruct.Pull = GPIO_NOPULL;
        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
        HAL_GPIO_Init(led_list[i].port, &GPIO_InitStruct);
    }
}

void drv_led_on(uint8_t id)
{
    HAL_GPIO_WritePin(led_list[id].port, led_list[id].pin, GPIO_PIN_SET);
}
```

---

### 例程03: KEY_EXTI

#### 功能说明
使用外部中断(EXTI)检测按键按下事件。

#### 核心代码分析

```c
// 按键GPIO初始化
static void key_gpio_init(void)
{
    rcu_periph_clock_enable(RCU_GPIOA);
    gpio_init(GPIOA, GPIO_MODE_IPU, GPIO_OSPEED_10MHZ, GPIO_PIN_0);

    rcu_periph_clock_enable(RCU_GPIOG);
    gpio_init(GPIOG, GPIO_MODE_IPU, GPIO_OSPEED_10MHZ,
              GPIO_PIN_13 | GPIO_PIN_14 | GPIO_PIN_15);
}

// 外部中断初始化
static void key_exti_init(void)
{
    rcu_periph_clock_enable(RCU_AF);  // 使能AF时钟（EXTI映射需要）

    // 将GPIO线映射到EXTI线
    gpio_exti_source_select(GPIO_PORT_SOURCE_GPIOA, GPIO_PIN_SOURCE_0);
    gpio_exti_source_select(GPIO_PORT_SOURCE_GPIOG, GPIO_PIN_SOURCE_13);
    gpio_exti_source_select(GPIO_PORT_SOURCE_GPIOG, GPIO_PIN_SOURCE_14);
    gpio_exti_source_select(GPIO_PORT_SOURCE_GPIOG, GPIO_PIN_SOURCE_15);

    // 配置EXTI：中断模式 + 下降沿触发
    exti_init(EXTI_0, EXTI_INTERRUPT, EXTI_TRIG_FALLING);
    exti_init(EXTI_13, EXTI_INTERRUPT, EXTI_TRIG_FALLING);
    exti_init(EXTI_14, EXTI_INTERRUPT, EXTI_TRIG_FALLING);
    exti_init(EXTI_15, EXTI_INTERRUPT, EXTI_TRIG_FALLING);

    // 清除中断标志
    exti_interrupt_flag_clear(EXTI_0);
    // ...

    // 使能NVIC中断
    nvic_irq_enable(EXTI0_IRQn, 1, 1);
    nvic_irq_enable(EXTI10_15_IRQn, 1, 1);
}

// EXTI0中断服务函数（对应PA0 - KEY1）
void EXTI0_IRQHandler(void)
{
    if (exti_interrupt_flag_get(EXTI_0) != RESET) {
        drv_led_on(LED1);
        exti_interrupt_flag_clear(EXTI_0);  // 清除中断标志
    }
}

// EXTI10_15中断服务函数（对应PG13/14/15 - KEY2/3/4）
void EXTI10_15_IRQHandler(void)
{
    if (exti_interrupt_flag_get(EXTI_13) != RESET) {
        drv_led_on(LED2);
        exti_interrupt_flag_clear(EXTI_13);
    }
    if (exti_interrupt_flag_get(EXTI_14) != RESET) {
        drv_led_off(LED1);
        exti_interrupt_flag_clear(EXTI_14);
    }
    if (exti_interrupt_flag_get(EXTI_15) != RESET) {
        drv_led_off(LED2);
        exti_interrupt_flag_clear(EXTI_15);
    }
}
```

#### 代码思路

1. **硬件连接**：
   - 按键连接到GPIO引脚，配置为上拉输入（IPU）
   - 按键按下时引脚电平为低（下降沿）

2. **EXTI配置流程**：
   - 使能AFIO时钟（复用功能时钟）
   - 将GPIO线映射到EXTI线
   - 配置EXTI为中断模式，下降沿触发
   - 使能NVIC中断

3. **中断处理**：
   - EXTI0单独一个中断向量
   - EXTI10~15共用一个中断向量
   - 中断处理函数内需清除中断标志位

#### STM32移植要点

| GD32 | STM32 | 说明 |
|------|-------|------|
| `rcu_periph_clock_enable(RCU_AF)` | `__HAL_RCC_AFIO_CLK_ENABLE()` | 使能AFIO时钟 |
| `gpio_exti_source_select()` | `GPIO_EXTILineConfig()` | 映射GPIO到EXTI |
| `exti_init()` | `HAL_GPIO_Init()` 配置EXTI | 配置外部中断 |
| `nvic_irq_enable()` | `HAL_NVIC_SetPriority()` + `HAL_NVIC_EnableIRQ()` | 配置NVIC |
| `EXTI0_IRQHandler` | `EXTI0_IRQHandler` | 中断函数名相同 |
| `exti_interrupt_flag_get()` | `__HAL_GPIO_EXTI_GET_FLAG()` | 获取中断标志 |
| `exti_interrupt_flag_clear()` | `__HAL_GPIO_EXTI_CLEAR_FLAG()` | 清除中断标志 |

**STM32 HAL移植示例**：
```c
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
    switch(GPIO_Pin) {
        case GPIO_PIN_0:  // KEY1
            drv_led_on(LED1);
            break;
        case GPIO_PIN_13: // KEY2
            drv_led_on(LED2);
            break;
        // ...
    }
}
```

---

### 例程04: KEY_SYSTICK_STATE

#### 功能说明
使用SysTick定时器实现按键状态机，支持短按、长按、双击检测。

#### 核心代码分析

```c
// 按键状态枚举
typedef enum {
    KEY_STATE_RELEASE = 0,    // 释放/空闲状态
    KEY_STATE_CONFIRM,        // 按下消抖确认阶段
    KEY_STATE_PRESSING,       // 短按事件
    KEY_STATE_LONG,           // 长按事件
} key_state_t;

// 按键信息结构体
typedef struct {
    key_state_t state;        // 当前按键状态
    uint8_t     click_cnt;    // 已确认的短按次数（用于双击判断）
    uint64_t    press_time;   // 稳定按下时刻(ms)
    uint64_t    release_time;  // 稳定释放时刻(ms)
} key_info_t;

static key_info_t g_key_info[KEY_MAX_NUM];

// 按键扫描函数（在主循环调用）
static uint8_t key_scan(uint8_t key_index)
{
    uint64_t now = sys_tick_get_runtime();
    uint8_t pressed = (gpio_input_bit_get(...) == RESET);  // 按下=0

    switch (g_key_info[key_index].state) {
        case KEY_STATE_RELEASE:
            // 双击检测窗口判断
            if (g_key_info[key_index].click_cnt == 1) {
                if ((now - g_key_info[key_index].release_time) > 300) {
                    // 超过300ms，判定为单击
                    g_key_info[key_index].click_cnt = 0;
                    return key_index + 0x01;  // 短按: 0x01~0x04
                }
            }
            // 检测按键按下
            if (pressed) {
                g_key_info[key_index].press_time = now;
                g_key_info[key_index].state = KEY_STATE_CONFIRM;
            }
            break;

        case KEY_STATE_CONFIRM:
            // 消抖确认，持续超过20ms认为有效
            if (pressed && (now - g_key_info[key_index].press_time) >= 20) {
                g_key_info[key_index].press_time = now;  // 重置计时起点
                g_key_info[key_index].state = KEY_STATE_PRESSING;
            } else if (!pressed) {
                // 消抖阶段松开，认为是抖动，返回空闲
                g_key_info[key_index].state = KEY_STATE_RELEASE;
            }
            break;

        case KEY_STATE_PRESSING:
            if (!pressed) {
                // 按键释放
                g_key_info[key_index].state = KEY_STATE_RELEASE;
                g_key_info[key_index].click_cnt++;

                if (g_key_info[key_index].click_cnt == 1) {
                    // 第一次释放，记录释放时刻，等待双击
                    g_key_info[key_index].release_time = now;
                } else {
                    // 第二次释放，判断是否为双击
                    if ((now - g_key_info[key_index].release_time) <= 300) {
                        g_key_info[key_index].click_cnt = 0;
                        return key_index + 0x51;  // 双击: 0x51~0x54
                    }
                    // 超时，将当前按击视为新的第一次
                    g_key_info[key_index].click_cnt = 1;
                    g_key_info[key_index].release_time = now;
                }
            } else if ((now - g_key_info[key_index].press_time) >= 800) {
                // 持续按下超过800ms，进入长按状态
                g_key_info[key_index].state = KEY_STATE_LONG;
            }
            break;

        case KEY_STATE_LONG:
            if (!pressed) {
                // 长按释放，返回长按事件
                g_key_info[key_index].state = KEY_STATE_RELEASE;
                g_key_info[key_index].click_cnt = 0;
                return key_index + 0x81;  // 长按: 0x81~0x84
            }
            break;
    }
    return 0;  // 无事件
}

// 主循环中获取按键值
uint8_t drv_get_key_val(void)
{
    for (uint8_t i = 0; i < KEY_MAX_NUM; i++) {
        uint8_t res = key_scan(i);
        if (res != 0) return res;
    }
    return KEY_NULL_PRESS;  // 0x00
}
```

#### 代码思路

1. **状态机设计**：
   - 状态：释放 → 消抖确认 → 短按检测 → 长按检测
   - 每个状态根据按键输入和超时进行状态转换

2. **事件定义**：
   ```
   0x00   - 无按键事件
   0x01~0x04  - KEY1~4 短按
   0x51~0x54  - KEY1~4 双击
   0x81~0x84  - KEY1~4 长按
   ```

3. **关键参数**：
   - 消抖时间：20ms
   - 长按时间：800ms
   - 双击间隔：300ms

4. **双击检测逻辑**：
   - 第一次释放后记录时间，等待300ms
   - 300ms内再次按下并释放 → 双击
   - 300ms内无动作 → 单击

#### STM32移植要点

| GD32 | STM32 | 说明 |
|------|-------|------|
| `gpio_input_bit_get()` | `HAL_GPIO_ReadPin()` | 读取GPIO电平 |
| `sys_tick_get_runtime()` | `HAL_GetTick()` | 获取系统运行时间(ms) |
| SysTick_Handler | SysTick_Handler | 相同 |
| 状态机逻辑 | 完全相同 | 可直接移植 |

---

### 例程05: UART基础

#### 功能说明
实现UART串口通信的基础功能，包括初始化、字符/字符串发送、printf重定向。

#### 核心代码分析

```c
// UART硬件信息结构体
typedef struct {
    uint32_t        uart_no;    // USART编号
    rcu_periph_enum rcu_uart;   // USART时钟
    rcu_periph_enum rcu_gpio;   // GPIO端口时钟
    uint32_t        gpio;       // GPIO端口
    uint32_t        tx_pin;     // TX引脚
    uint32_t        rx_pin;     // RX引脚
} uart_hwinfo_t;

static const uart_hwinfo_t g_uart_hwinfo = {
    USART0, RCU_USART0, RCU_GPIOA, GPIOA, GPIO_PIN_9, GPIO_PIN_10
};

// GPIO初始化
static void uart_gpio_init(void)
{
    rcu_periph_clock_enable(g_uart_hwinfo.rcu_gpio);

    // TX: 复用推挽输出
    gpio_init(g_uart_hwinfo.gpio, GPIO_MODE_AF_PP,
              GPIO_OSPEED_10MHZ, g_uart_hwinfo.tx_pin);

    // RX: 浮空输入
    gpio_init(g_uart_hwinfo.gpio, GPIO_MODE_IPU,
              GPIO_OSPEED_10MHZ, g_uart_hwinfo.rx_pin);
}

// UART初始化
static void uart_init(uint32_t baud_rate)
{
    rcu_periph_clock_enable(g_uart_hwinfo.rcu_uart);
    usart_deinit(g_uart_hwinfo.uart_no);

    // 8数据位，无校验，1停止位 (8N1)
    usart_word_length_set(g_uart_hwinfo.uart_no, USART_WL_8BIT);
    usart_parity_config(g_uart_hwinfo.uart_no, USART_PM_NONE);
    usart_stop_bit_set(g_uart_hwinfo.uart_no, USART_STB_1BIT);

    usart_baudrate_set(g_uart_hwinfo.uart_no, baud_rate);
    usart_transmit_config(g_uart_hwinfo.uart_no, USART_TRANSMIT_ENABLE);
    usart_enable(g_uart_hwinfo.uart_no);
}

// 发送单个字符
void uart_send_char(const char ch)
{
    usart_data_transmit(g_uart_hwinfo.uart_no, (uint8_t)ch);
    while (usart_flag_get(g_uart_hwinfo.uart_no, USART_FLAG_TBE) == RESET);
}

// 发送字符串
void uart_send_string(const char *str)
{
    while (*str != '\0') {
        uart_send_char(*str++);
    }
}

// printf重定向
int fputc(int ch, FILE *f)
{
    uart_send_char((uint8_t)ch);
    return ch;
}
```

#### 代码思路

1. **UART配置流程**：
   - 使能GPIO和UART时钟
   - 配置TX为复用推挽输出，RX为上拉输入
   - 配置UART参数：8N1格式，指定波特率
   - 使能发送功能和UART外设

2. **发送机制**：
   - 查询方式：等待发送缓冲区空标志（TBE）
   - 发送完成后才能发送下一个字节

3. **printf重定向**：
   - 重写`fputc()`函数，将字符输出到UART

#### STM32移植要点

| GD32 | STM32 | 说明 |
|------|-------|------|
| `rcu_periph_clock_enable()` | `__HAL_RCC_USARTx_CLK_ENABLE()` | 使能UART时钟 |
| `gpio_init()` | `HAL_GPIO_Init()` | GPIO初始化 |
| `usart_deinit()` | `HAL_UART_DeInit()` | 复位UART |
| `usart_word_length_set()` | `UART配置结构体.WordLength` | 数据位 |
| `usart_parity_config()` | `UART配置结构体.Parity` | 校验位 |
| `usart_stop_bit_set()` | `UART配置结构体.StopBits` | 停止位 |
| `usart_baudrate_set()` | `UART配置结构体.BaudRate` | 波特率 |
| `usart_data_transmit()` | `HAL_UART_Transmit()` | 发送数据 |
| `usart_flag_get()` | `HAL_UART_GetState()` | 获取状态 |
| `USART_FLAG_TBE` | `HAL_UART_STATE_READY` | 发送缓冲区空 |

**STM32 HAL移植示例**：
```c
UART_HandleTypeDef huart1;

void drv_uart_init(uint32_t baud_rate)
{
    huart1.Instance = USART1;
    huart1.Init.BaudRate = baud_rate;
    huart1.Init.WordLength = UART_WORDLENGTH_8B;
    huart1.Init.StopBits = UART_STOPBITS_1;
    huart1.Init.Parity = UART_PARITY_NONE;
    huart1.Init.Mode = UART_MODE_TX_RX;
    huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
    huart1.Init.OverSampling = UART_OVERSAMPLING_16;
    HAL_UART_Init(&huart1);
}

int fputc(int ch, FILE *f)
{
    HAL_UART_Transmit(&huart1, (uint8_t*)&ch, 1, 100);
    return ch;
}
```

---

### 例程06: UART控制

#### 功能说明
在UART基础上添加任务轮询机制，实现非阻塞式数据处理。

#### 代码思路

```c
int main(void)
{
    sys_init();
    drv_init();

    while (1) {
        drv_uart_task();  // 在主循环中调用UART任务
    }
}
```

1. **任务化设计**：
   - 将UART处理封装成`drv_uart_task()`函数
   - 在主循环中轮询调用，实现非阻塞式操作

2. **优点**：
   - 避免在主循环中直接处理复杂逻辑
   - 便于后续扩展为定时任务

---

### 例程07: UART应用层

#### 功能说明
实现自定义通信协议，支持数据帧解析和LED控制。

#### 协议格式

```
帧头1 | 帧头2 | 长度 | 功能码 | 数据0 | 数据1 | 校验
0x55  | 0xAA  | 0x03  | 0x06  | led_num | led_state | XOR
```

#### 核心代码分析

```c
#define DATA_HEAD_ONE  0x55
#define DATA_HEAD_TOW  0xAA
#define FUNC_DATA_IDX  3
#define LED_CTRL_CODE  0x06

// 接收缓冲区和标志
static bool g_rc_succeed_flag = false;
static uint8_t g_rc_buf[RX_BUF_SIZE];

// 帧解析状态机
static void pro_uart_data(uint8_t dat)
{
    static uint8_t index = 0;
    g_rc_buf[index++] = dat;

    switch (index) {
        case 1:
            if (g_rc_buf[0] != DATA_HEAD_ONE)
                index = 0;  // 帧头错误，重新同步
            break;
        case 2:
            if (g_rc_buf[1] != DATA_HEAD_TOW)
                index = 0;  // 帧头错误，重新同步
            break;
        case 7:
            // 接收到完整一帧（固定7字节）
            g_rc_succeed_flag = true;
            index = 0;
            break;
    }
}

// XOR校验计算
static uint8_t cal_xor_sum(const uint8_t *data, uint8_t len)
{
    uint8_t xor_sum = 0;
    for (uint8_t i = 0; i < len; i++) {
        xor_sum ^= data[i];
    }
    return xor_sum;
}

// 应用层任务处理
void app_uart_task(void)
{
    if (!g_rc_succeed_flag) return;

    g_rc_succeed_flag = false;  // 清除标志

    // 校验检查
    if (cal_xor_sum(g_rc_buf, PACKET_DATA_LEN - 1) != g_rc_buf[PACKET_DATA_LEN - 1])
        return;  // 校验失败

    // 业务逻辑分发
    if (g_rc_buf[FUNC_DATA_IDX] == LED_CTRL_CODE) {
        led_ctrl_inof_t *p = (led_ctrl_inof_t*)(&g_rc_buf[FUNC_DATA_IDX + 1]);
        (p->led_state != 0) ? drv_led_on(p->led_num) : drv_led_off(p->led_num);
    }
}
```

#### 代码思路

1. **帧解析状态机**：
   - 逐字节接收数据
   - 通过静态变量`index`记录接收位置
   - 帧头错误时重新同步（index=0）

2. **校验机制**：
   - 使用XOR校验：所有字节异或，结果与校验字节对比
   - 简单有效，检测单字节错误

3. **数据流**：
   ```
   UART中断 → pro_uart_data() 逐字节组帧
              → g_rc_succeed_flag = true
              → app_uart_task() 校验+执行业务逻辑
   ```

#### STM32移植要点

- 协议解析逻辑完全相同，可直接移植
- 需要适配UART接收中断回调函数

---

### 例程08: UART队列

#### 功能说明
使用FIFO队列管理UART接收数据，实现中断与任务间的数据传递。

#### 核心代码分析

```c
// 队列结构体
typedef struct {
    uint8_t *buffer;   // 缓冲区指针
    uint32_t size;     // 缓冲区大小
    uint32_t head;     // 队头索引
    uint32_t tail;     // 队尾索引
} QueueType_t;

// 队列初始化
void QueueInit(QueueType_t *queue, uint8_t *buffer, uint32_t size)
{
    queue->buffer = buffer;
    queue->size = size;
    queue->head = 0;
    queue->tail = 0;
}

// 入队
QueueStatus_t QueuePush(QueueType_t *queue, uint8_t data)
{
    uint32_t index = (queue->tail + 1) % queue->size;

    if (index == queue->head) {
        return QUEUE_OVERLOAD;  // 队列满
    }

    queue->buffer[queue->tail] = data;
    queue->tail = index;
    return QUEUE_OK;
}

// 出队
QueueStatus_t QueuePop(QueueType_t *queue, uint8_t *pdata)
{
    if (queue->head == queue->tail) {
        return QUEUE_EMPTY;  // 队列空
    }

    *pdata = queue->buffer[queue->head];
    queue->head = (queue->head + 1) % queue->size;
    return QUEUE_OK;
}

// 获取队列中数据个数
uint32_t QueueCount(QueueType_t *queue)
{
    if (queue->head <= queue->tail)
        return queue->tail - queue->head;
    return queue->size + queue->tail - queue->head;
}
```

#### 代码思路

1. **环形队列设计**：
   - 使用模运算实现环形缓冲
   - `head`指向队首，`tail`指向队尾下一个位置
   - 判断队列满：`(tail + 1) % size == head`
   - 判断队列空：`head == tail`

2. **数据流**：
   ```
   UART中断 → QueuePush() 将接收数据入队
              → 主循环 → QueuePop() 取出数据处理
   ```

3. **优点**：
   - 解耦中断和主循环
   - 避免数据丢失（队列缓存）
   - 支持批量处理

#### STM32移植要点

- 队列算法完全相同，可直接移植
- 可考虑使用ST的`RingBuffer`库

---

### 例程09: UART DMA

#### 功能说明
使用DMA实现UART数据传输，减轻CPU负担。

#### 代码思路

1. **DMA发送**：
   - 配置DMA源地址（UART数据寄存器）
   - 配置DMA目标地址（发送缓冲区）
   - 启动DMA传输

2. **DMA接收**：
   - 配置为循环模式，持续接收
   - 配置空闲中断，检测一帧结束

#### STM32移植要点

| GD32 | STM32 | 说明 |
|------|-------|------|
| `dma_deinit()` | `HAL_DMA_DeInit()` | DMA复位 |
| `dma_init()` | `HAL_DMA_Init()` | DMA初始化 |
| `dma_circulation_enable()` | `DMA配置结构体.CircleMode` | 循环模式 |
| `dma_channel_enable()` | `HAL_DMA_Start()` | 启动DMA |
| UART的DMA请求 | UART配置结构体.DMATx | 使能UART的DMA |

**STM32 HAL使用示例**：
```c
// DMA发送
HAL_UART_Transmit_DMA(&huart1, tx_buffer, len);

// DMA接收（循环模式）
HAL_UART_Receive_DMA(&huart1, rx_buffer, RX_BUF_SIZE);
```

---

### 例程10: 任务运行管理

#### 功能说明
实现简易的任务调度器，支持定时任务调度。

#### 核心代码分析

```c
// 任务结构体
typedef struct {
    volatile bool is_ready;    // 就绪标志（ISR置位，task_loop执行后清零）
    uint64_t      ticks_left;  // 剩余tick数（倒计时）
    uint64_t      period_ticks;// 周期tick数（自动重装载）
    task_cb_t     cb;          // 任务回调函数
} task_t;

// 任务配置表
static task_t g_task_table[] = {
    { false, 100, 100, app_uart_task },  // 100ms执行一次
    { false, 5,   5,   app_key_task  },  // 5ms执行一次
};

// 1ms tick钩子函数（在SysTick中断中调用）
static void task_tick_hook(void)
{
    for (uint8_t i = 0; i < TASK_COUNT; i++) {
        if (g_task_table[i].period_ticks == 0) continue;  // 非周期任务

        // 倒计时
        if (g_task_table[i].ticks_left > 0)
            g_task_table[i].ticks_left--;

        // 到期，置位就绪标志并重装载
        if (g_task_table[i].ticks_left == 0) {
            g_task_table[i].is_ready = true;
            g_task_table[i].ticks_left = g_task_table[i].period_ticks;
        }
    }
}

// 主循环任务调度
void task_loop(void)
{
    for (uint8_t i = 0; i < TASK_COUNT; i++) {
        if (g_task_table[i].is_ready) {
            g_task_table[i].is_ready = false;
            if (g_task_table[i].cb)
                g_task_table[i].cb();  // 执行任务回调
        }
    }
}
```

#### 代码思路

1. **调度器设计**：
   - 每个任务配置周期和回调函数
   - 1ms中断中倒计时，到期时置位`is_ready`
   - 主循环轮询就绪标志，执行对应任务

2. **数据流**：
   ```
   SysTick中断(1ms) → task_tick_hook() 倒计时
                     → ticks_left == 0 → is_ready = true
                     → 主循环 → task_loop() → 执行回调
   ```

3. **优点**：
   - 轻量级调度器
   - 非阻塞，不使用RTOS
   - 支持多任务并发

#### STM32移植要点

- 调度器算法完全相同，可直接移植
- 需要在`SysTick_Handler()`中调用`task_tick_hook()`

---

### 例程11: 定时器计数

#### 功能说明
使用定时器进行计数，演示基本定时器功能。

#### 代码思路

1. **定时器配置**：
   - 配置定时器时钟分频
   - 设置自动重装载值
   - 启动定时器

2. **应用场景**：
   - 周期性任务触发
   - PWM波形生成
   - 输入捕获测量

#### STM32移植要点

| GD32 | STM32 | 说明 |
|------|-------|------|
| `rcu_periph_clock_enable(RCU_TIMERx)` | `__HAL_RCC_TIMx_CLK_ENABLE()` | 使能定时器时钟 |
| `timer_deinit()` | `HAL_TIM_Base_DeInit()` | 复位定时器 |
| `timer_init()` | `HAL_TIM_Base_Init()` | 初始化定时器 |
| `timer_enable()` | `HAL_TIM_Base_Start()` | 启动定时器 |
| `timer_interrupt_enable()` | `HAL_TIM_Base_Start_IT()` | 启动中断 |

---

### 例程12: 输出比较(PWM)

#### 功能说明
使用定时器输出比较功能，生成PWM波形控制LED亮度。

#### 核心代码分析

```c
// GPIO初始化
static void GPIO_Init(void)
{
    rcu_periph_clock_enable(RCU_GPIOA);
    // PA8配置为复用推挽输出（对应TIMER0_CH0）
    gpio_init(GPIOA, GPIO_MODE_AF_PP, GPIO_OSPEED_MAX, GPIO_PIN_8);
}

// 定时器PWM初始化
static void timerinit(void)
{
    rcu_periph_clock_enable(RCU_TIMER0);
    timer_deinit(TIMER0);

    // 定时器参数
    timer_parameter_struct timerInitPara;
    timer_struct_para_init(&timerInitPara);

    timerInitPara.prescaler = 120 - 1;   // 120MHz/120 = 1MHz (1us/tick)
    timerInitPara.period = 500 - 1;      // 500us -> 2kHz频率
    timer_init(TIMER0, &timerInitPara);

    // PWM通道配置
    timer_oc_parameter_struct ocPara;
    timer_channel_output_struct_para_init(&ocPara);

    ocPara.outputstate  = TIMER_CCX_ENABLE;           // 使能通道
    ocPara.ocpolarity   = TIMER_OC_POLARITY_HIGH;     // 高电平有效
    ocPara.ocidlestate  = TIMER_OC_IDLE_STATE_LOW;      // 空闲低电平
    timer_channel_output_config(TIMER0, TIMER_CH_0, &ocPara);

    // PWM模式
    timer_channel_output_mode_config(TIMER0, TIMER_CH_0, TIMER_OC_MODE_PWM0);

    // 设置占空比
    timer_channel_output_pulse_value_config(TIMER0, TIMER_CH_0, 250);  // 50%

    // 主输出使能（TIMER0高级定时器需要）
    timer_primary_output_config(TIMER0, ENABLE);

    timer_enable(TIMER0);
}

// 呼吸灯效果
void led_pwm_test(void)
{
    // 亮度渐亮
    for(uint32_t i = 0; i < 500; i++) {
        timer_channel_output_pulse_value_config(TIMER0, TIMER_CH_0, i);
        delay_ms(1);
    }
    // 亮度渐暗
    for(uint32_t i = 500; i > 0; i--) {
        timer_channel_output_pulse_value_config(TIMER0, TIMER_CH_0, i);
        delay_ms(1);
    }
}
```

#### 代码思路

1. **PWM原理**：
   ```
   PWM频率 = 时钟频率 / (预分频+1) / (重装载值+1)
   占空比 = CCR / (ARR+1) * 100%
   ```

2. **参数计算**（本例）：
   - CPU时钟：120MHz
   - 预分频：120 → 定时器时钟1MHz
   - 重装载值：499 → PWM周期500us → 频率2kHz
   - CCR值：0~499，对应0%~100%占空比

3. **呼吸灯实现**：
   - CCR从0渐变到ARR → 亮度渐亮
   - CRR从ARR渐变到0 → 亮度渐暗

#### STM32移植要点

| GD32 | STM32 | 说明 |
|------|-------|------|
| `timer_init()` | `HAL_TIM_PWM_Init()` | PWM初始化 |
| `timer_channel_output_config()` | `HAL_TIM_PWM_ConfigChannel()` | PWM通道配置 |
| `timer_channel_output_mode_config()` | `OCM配置` | PWM模式 |
| `timer_channel_output_pulse_value_config()` | `__HAL_TIM_SET_COMPARE()` | 设置CCR |
| `timer_primary_output_config()` | `TIM_BDTRInit` | 高级定时器主输出使能 |

**STM32 HAL移植示例**：
```c
TIM_HandleTypeDef htim1;
TIM_OC_InitTypeDef sConfigOC = {0};

// 定时器初始化
htim1.Instance = TIM1;
htim1.Init.Prescaler = 120 - 1;
htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
htim1.Init.Period = 500 - 1;
HAL_TIM_PWM_Init(&htim1);

// PWM通道配置
sConfigOC.OCMode = TIM_OCMODE_PWM1;
sConfigOC.Pulse = 250;
sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1);

// 启动PWM
HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1);

// 动态调整占空比
__HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_1, new_value);
```

---

### 例程13: 输入捕获

#### 功能说明
使用定时器输入捕获功能，测量外部信号的周期。

#### 核心代码分析

```c
static uint32_t g_ic_val = 0;  // 捕获值

// GPIO初始化
static void GPIO_Init(void)
{
    rcu_periph_clock_enable(RCU_GPIOA);
    // PA0配置为浮空输入
    gpio_init(GPIOA, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_MAX, GPIO_PIN_0);
}

// 定时器捕获初始化
static void timerinit(void)
{
    rcu_periph_clock_enable(RCU_TIMER1);
    timer_deinit(TIMER1);

    // 定时器参数：1us/tick
    timer_parameter_struct timerInitPara;
    timerInitPara.prescaler = 120 - 1;  // 120MHz/120 = 1MHz
    timerInitPara.period = 65535;        // 最大计数值
    timer_init(TIMER1, &timerInitPara);

    // 输入捕获配置
    timer_ic_parameter_struct icInitPara;
    timer_channel_input_struct_para_init(&icInitPara);

    icInitPara.icpolarity  = TIMER_IC_POLARITY_RISING;   // 上升沿捕获
    icInitPara.icselection = TIMER_IC_SELECTION_DIRECTTI; // 直连TI1
    timer_input_capture_config(TIMER1, TIMER_CH_0, &icInitPara);

    // 中断配置
    timer_interrupt_flag_clear(TIMER1, TIMER_INT_FLAG_CH0);
    timer_interrupt_enable(TIMER1, TIMER_INT_FLAG_CH0);
    nvic_irq_enable(TIMER1_IRQn, 0, 0);

    timer_enable(TIMER1);
}

// 捕获中断服务函数
void TIMER1_IRQHandler(void)
{
    if (timer_interrupt_flag_get(TIMER1, TIMER_INT_FLAG_CH0) == SET) {
        // 读取捕获值（单位：us）
        g_ic_val = timer_channel_capture_value_register_read(TIMER1, TIMER_CH_0) + 1;

        // 清零计数器，重新开始计时
        timer_counter_value_config(TIMER1, 0);

        timer_interrupt_flag_clear(TIMER1, TIMER_INT_FLAG_CH0);
    }
}

// 测试函数
void capture_test(void)
{
    printf("period is %d us\r\n", g_ic_val);
}
```

#### 代码思路

1. **输入捕获原理**：
   - 定时器在指定边沿触发时，将当前计数值保存到CCR寄存器
   - 连续两次捕获的CCR差值即为信号周期

2. **配置要点**：
   - 设置捕获极性（上升沿/下降沿）
   - 选择触发源（直连/交叉连接）
   - 使能捕获中断

3. **数据处理**：
   - 每次捕获后清零计数器
   - 下次捕获值即为上一周期时间

#### STM32移植要点

| GD32 | STM32 | 说明 |
|------|-------|------|
| `timer_input_capture_config()` | `HAL_TIM_IC_ConfigChannel()` | 输入捕获配置 |
| `timer_channel_capture_value_register_read()` | `__HAL_TIM_GET_COMPARE()` | 读取捕获值 |
| `TIMER_IC_POLARITY_RISING` | `TIM_ICPOLARITY_RISING` | 上升沿捕获 |
| `TIMER_IC_SELECTION_DIRECTTI` | `TIM_ICSELECTION_DIRECTTI` | 直连模式 |

**STM32 HAL移植示例**：
```c
TIM_HandleTypeDef htim1;

// 输入捕获初始化
htim1.Instance = TIM1;
htim1.Init.Prescaler = 120 - 1;
htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
htim1.Init.Period = 65535;
HAL_TIM_IC_Init(&htim1);

// 捕获通道配置
TIM_IC_InitTypeDef sConfigIC = {0};
sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING;
sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI;
sConfigIC.ICPrescaler = TIM_ICPSC_DIV1;
sConfigIC.ICFilter = 0;
HAL_TIM_IC_ConfigChannel(&htim1, &sConfigIC, TIM_CHANNEL_1);

// 启动捕获
HAL_TIM_IC_Start_IT(&htim1, TIM_CHANNEL_1);

// 捕获回调
void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
    if (htim->Instance == TIM1) {
        g_ic_val = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);
        __HAL_TIM_SET_COUNTER(htim, 0);  // 清零计数器
    }
}
```

---

### 例程14: IR_NEC红外解码

#### 功能说明
使用定时器输入捕获解码NEC红外协议。

#### NEC协议格式

```
引导码 | 地址码 | 地址反码 | 命令码 | 命令反码
9ms+4.5ms | 8位 | 8位 | 8位 | 8位

逻辑0: 560us低电平 + 560us高电平 = 1.12ms
逻辑1: 560us低电平 + 1680us高电平 = 2.25ms
```

#### 核心代码分析

```c
// 时间阈值（单位：us）
#define TICK_HEADER_MIN  10000U   // 引导码最小值
#define TICK_HEADER_MAX  20000U   // 引导码最大值
#define TICK_0_MIN       500U      // 逻辑0最小值
#define TICK_0_MAX       1800U     // 逻辑0最大值
#define TICK_1_MIN       1800U     // 逻辑1最小值
#define TICK_1_MAX       3000U     // 逻辑1最大值

static uint8_t g_ir_code_raw[4] = {0};  // 接收数据：[地址, ~地址, 命令, ~命令]
static bool g_ir_code_flag = false;

// 帧解析函数（在中断中调用）
static void parse_ir_frame(uint32_t tick_us)
{
    static bool s_head_flag = false;
    static uint8_t s_index = 0;

    // 1) 引导码检测
    if ((tick_us > TICK_HEADER_MIN) && (tick_us < TICK_HEADER_MAX)) {
        s_head_flag = true;
        return;
    }

    // 2) 未检测到引导码，跳过
    if (!s_head_flag) return;

    // 3) 逻辑1解析
    if ((tick_us > TICK_1_MIN) && (tick_us < TICK_1_MAX)) {
        g_ir_code_raw[s_index / 8] >>= 1;  // 右移1位
        g_ir_code_raw[s_index / 8] |= 0x80U;  // 最高位置1
        s_index++;
    }

    // 4) 逻辑0解析
    else if ((tick_us > TICK_0_MIN) && (tick_us < TICK_0_MAX)) {
        g_ir_code_raw[s_index / 8] >>= 1;  // 仅右移，最高位为0
        s_index++;
    }

    // 5) 接收32位完成，校验
    if (s_index == 32U) {
        // NEC校验：命令与命令反码相与应为0
        if ((g_ir_code_raw[2] & g_ir_code_raw[3]) == 0U) {
            g_ir_code_flag = true;
        }
        s_head_flag = false;
        s_index = 0U;
    }
}

// 捕获中断服务函数
void TIMER7_Channel_IRQHandler(void)
{
    if (timer_interrupt_flag_get(TIMER7, TIMER_INT_FLAG_CH0) == SET) {
        uint32_t ic_val_us = timer_channel_capture_value_register_read(TIMER7, TIMER_CH_0) + 1;
        timer_counter_value_config(TIMER7, 0U);  // 清零计数器
        parse_ir_frame(ic_val_us);  // 解析帧
        timer_interrupt_flag_clear(TIMER7, TIMER_INT_FLAG_CH0);
    }
}

// 获取红外码
bool drv_ir_get_code(uint8_t *ircode)
{
    if (!g_ir_code_flag) return false;
    *ircode = g_ir_code_raw[2];  // 返回命令码
    g_ir_code_flag = false;
    return true;
}
```

#### 代码思路

1. **下降沿捕获策略**：
   - 配置为下降沿捕获
   - 每次捕获的值为低电平持续时间

2. **位接收逻辑**：
   - 先右移一位（为新bit腾出位置）
   - 逻辑0：仅右移，最高位为0
   - 逻辑1：右移后置最高位为1
   - 按从高位到低位顺序接收

3. **引导码检测**：
   - 检测到引导码后才开始解析后续bit
   - 避免误触发

4. **数据校验**：
   - NEC协议：命令码和命令反码应该按位取反
   - 校验通过：`cmd & ~cmd == 0`

#### STM32移植要点

- 协议解析逻辑完全相同
- 需根据硬件调整GPIO引脚和定时器通道

---

### 例程15: 输入捕获进阶

#### 功能说明
在例程13基础上扩展，展示更复杂的输入捕获应用。

#### 代码思路

- 基本原理与例程13相同
- 可扩展为测量脉宽、频率等应用

---

### 例程16: 时间戳和日历转换

#### 功能说明
使用标准库`time.h`进行时间戳和日历格式转换。

#### 核心代码分析

```c
#include <time.h>

int main(void)
{
    sys_init();
    drv_init();
    app_init();

    // 时间戳
    time_t timestamp = 1000000000;

    // 转换为UTC时间
    struct tm *timeInfo = NULL;
    timeInfo = gmtime(&timestamp);
    printf("gmttime: %d-%d-%d %d:%d:%d\r\n",
           timeInfo->tm_year + 1900,  // tm_year是从1900开始的偏移
           timeInfo->tm_mon + 1,       // tm_mon是0~11
           timeInfo->tm_mday,
           timeInfo->tm_hour,
           timeInfo->tm_min,
           timeInfo->tm_sec);

    // 转换为本地时间
    timeInfo = localtime(&timestamp);
    printf("localtime: %d-%d-%d %d:%d:%d\r\n",
           timeInfo->tm_year + 1900,
           timeInfo->tm_mon + 1,
           timeInfo->tm_mday,
           timeInfo->tm_hour,
           timeInfo->tm_min,
           timeInfo->tm_sec);

    // 格式化输出
    char *a = asctime(timeInfo);
    printf("string: %s\r\n", a);

    while (1) {
        // ...
    }
}
```

#### 代码思路

1. **标准库函数**：
   - `gmtime()`: 将时间戳转换为UTC时间
   - `localtime()`: 将时间戳转换为本地时间
   - `asctime()`: 将tm结构格式化为字符串

2. **tm结构体注意事项**：
   - `tm_year`: 从1900年开始的年份偏移
   - `tm_mon`: 0~11（0代表1月）
   - `tm_mday`: 1~31

#### STM32移植要点

- 完全依赖标准C库，移植无障碍
- 需确保编译器支持`time.h`

---

## STM32移植要点

### 1. 库函数对照表

| 功能 | GD32 | STM32 HAL |
|------|-------|-----------|
| GPIO初始化 | `gpio_init()` | `HAL_GPIO_Init()` |
| GPIO读写 | `gpio_bit_set/reset/input_bit_get()` | `HAL_GPIO_WritePin/ReadPin()` |
| UART初始化 | `usart_init()` | `HAL_UART_Init()` |
| UART发送 | `usart_data_transmit()` | `HAL_UART_Transmit()` |
| 定时器PWM | `timer_channel_output_config()` | `HAL_TIM_PWM_ConfigChannel()` |
| 输入捕获 | `timer_input_capture_config()` | `HAL_TIM_IC_ConfigChannel()` |
| 中断配置 | `nvic_irq_enable()` | `HAL_NVIC_SetPriority/EnableIRQ()` |
| 延时 | `delay_us/ms()` | `HAL_Delay()`（ms） |

### 2. 寄存器级别对照

| 寄存器 | GD32 | STM32 |
|--------|-------|-------|
| GPIO | `GPIOx` | `GPIOx` |
| UART | `USARTx` | `USARTx/UARTx` |
| 定时器 | `TIMERx` | `TIMx` |
| NVIC | `NVIC` | `NVIC` |
| SysTick | `SysTick` | `SysTick` |
| DWT | `DWT` | `DWT` |

### 3. 移植步骤

1. **硬件层适配**：
   - 根据原理图修改GPIO引脚定义
   - 修改时钟配置代码

2. **库函数替换**：
   - GD32标准库 → STM32 HAL库
   - 或直接使用寄存器操作

3. **中断向量表**：
   - 检查中断向量表是否一致
   - 部分外设中断名称可能不同

4. **测试验证**：
   - 逐个功能模块测试
   - 注意时钟频率差异（计算定时器参数时）

### 4. 常见差异

| 项目 | GD32 | STM32 |
|------|-------|-------|
| 时钟树 | RCU | RCC |
| 复用功能 | GPIO_MODE_AF_PP | 需要配置AFR |
| 高级定时器主输出 | `timer_primary_output_config()` | `TIM_BDTR`配置 |
| DMA请求 | 直接映射 | 需要配置DMA请求映射 |

---

## 总结

本项目展示了GD32嵌入式开发的完整流程，从基础的GPIO控制到复杂的协议解析和红外解码，涵盖了嵌入式开发的核心知识点：

1. **硬件抽象**：驱动层封装，提高代码可移植性
2. **状态机设计**：按键检测、协议解析等应用
3. **中断与DMA**：提高系统效率
4. **任务调度**：简化主循环逻辑
5. **协议栈设计**：帧格式、校验、业务逻辑分离

移植到STM32时，主要工作是替换底层库函数调用，上层业务逻辑可以直接复用。
